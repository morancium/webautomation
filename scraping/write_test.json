[{"title": "Introduction", "body": "Write tests for websites or web appsOverviewNightwatch provides simple and comprehensive APIs for interacting with web elements and performing various actions and assertions. In Nightwatch v3, brand new element APIs are introduced to make writing tests even simpler and more concise. The Nightwatch inspector makes it easier to author tests as it provides selector recommendations that are durable in the longer run. If you know very little or no coding, you can also use our Chrome recorder extension to record tests and run them using Nightwatch. Finding elementsBefore you can interact with elements or perform assertions, you will have to find the elements from the DOM tree using selectors. Nightwatch supports a variety of selectors to make finding elements a breeze. You can do so using .find() & .findAll() related commands:CSS selectors :browser.element.find('css selector');browser.element.findAll('css selector');xPath selector :browser.element.find(by.xpath(('xpath string'));browser.element.findAll(by.xpath(('xpath string'));By role :browser.element.findByRole('role');browser.element.findAllByRole('role');By  text :browser.element.findByText('text');browser.element.findAllByText('text');By placeholder text :browser.element.findByPlaceholderText('placeholder text');browser.element.findAllByPlaceholderText('placeholder text');By label text :browser.element.findByLabelText('label text');browser.element.findAllByLabelText('label text');By alt text :browser.element.findByAltText('alt text');browser.element.findAllByAltText('alt text');Along with the find commands, Nightwatch also provides with convenience methods that help finding methods in more complex scenariosFinding nth element from an array of elements .nth(index)Finding count of element array .count()Finding nested elementsOn top of this powerful set of selectors, Nightwatch also supports selector chaining:browser.element.find('CSS selector').findByText('text').click();// orbrowser.element.findAll('CSS selector').nth(2).findByText('text').click();For a more detailed guide & examples on selectors, please refer to this guide.CommandsOnce you find elements, you can interact with them using commandsInteraction commandsClick :browser.element.find('selector').click();Double Click : browser.element.find('selector').doubleClick();Right Click : browser.element.find('selector').rightClick();Type into an input : browser.element.find('selector').sendKeys('text');Set Value : browser.element.find('selector').setValue();Clear : browser.element.find('selector').clear();Instead of .find(), you could also have used other find related methods such as .findByText(), .findByRole() followed by the commandGet element detailsGet text :browser.element.find('selector').getText();Get value :browser.element.find('selector').getValue();Get tag name :browser.element.find('selector').getTagName();Get attribute :browser.element.find('selector').getAttribute();Get CSS property :browser.element.find('selector').getCssProperty();Get ID :browser.element.find('selector').getId();Get Accessibility name :browser.element.find('selector').getAccessibilityName();Get rect :browser.element.find('selector').getRect();Update element detailsSet text :browser.element.find('selector').setText('text');Set attribute :browser.element.find('selector').setAttributes('attribute', 'attribute value');Setting browser contextSet Geolocation : browser.setGeolocation({latitude: , longitude: , accuracy: 100});Refer to this guide for detailed examples. You can also write custom commands with Nightwatch.Try nowAssertionsThe main point of writing automated tests is setting assertions to pass. There are 2 ways to do assertions with NightwatchYou can use the built-in assertionsText equals :browser.element.find('selector').assert.textEquals('text');Text contains :browser.element.find('selector').assert.textContains('text');Text matches :browser.element.find('selector').assert.textMatches('regex');Value equals :browser.element.find('selector').assert.valueEquals('text');Value contains :browser.element.find('selector').assert.valueContains('text');Value matches :browser.element.find('selector').assert.valueMatches('regex');URL equals :browser.assert.urlEquals('text');URL contains :browser.assert.urlContains('text');URL matches :browser.assert.urlMatches('regex');Visible :browser.element.find('selector').assert.visible();If these assertions don't suffice, you can write your own custom assertions. Learn howChai expectsIf you prefer Chai style asserts, you can also use the expect() to perform assertionsText equals :expect(element).text.to.equal();Text contains :expect(element).text.to.contain();Text equals :expect(element).text.to.match();Value equals :expect(element).value.to.equal();Value contains :expect(element).value.to.contain();Value equals :expect(element).value.to.match();URL equals :expect(brower.url()).to.equal();URL contains :expect(brower.url()).to.contain();URL matches :expect(brower.url()).to.match();Visible :expect(element).to.be.visible();For detailed examples around assertions, refer to this articleUsing Nightwatch inspectorNightwatch inspector is a point-and-click tool designed to save your time while authoring tests and help you write more durable tests. It also allows you to try out Nightwatch commands from devtools itself. Learn more.Record using Chrome dev toolsAlternatively, Nightwatch provides tools to help you get started by recording your test actions on screen and generate Nightwatch test scripts automatically without having to write any code. Explore Create Nightwatch test using Google Chrome DevTools Recorder for more information.Recommended next stepsNow that you understand the basics of writing tests for mobile apps, it's time to understand selectors, commands & assertions in more detailSelectorsCommandAssertions\u2190BackInstall NightwatchsNext PageSelectors\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/introduction.html"}, {"title": "Commands", "body": "Commands for websites or web appsOverviewUsing commands, you can interact with web elements. Before using commands, it is mandatory to find the element 1st . Please refer to this guide to understand to find elements using selectors. Commands can be categorized in 4 bucketsElement interactionsGet element detailsUpdate element detailsSetting browser contextClickTo click on an element,simply use browser.element.find('selector').click().// Click on the sign in buttonbrowser.element.findByText('Sign In').click();// Click on the sign in buttonbrowser.element.findByText('Sign In').click();Double ClickTo double click on an element,you can use browser.element.find('selector').doubleClick().// Double click on the sign in buttonbrowser.element.findByText('Sign In').doubleClick();// Double click on the sign in buttonbrowser.element.findByText('Sign In').doubleClick();Right ClickYou can right click on an element using browser.element.find('selector').rightClick().// Right click on the options buttonbrowser.element.findByText('options').rightClick();// Right click on the options buttonbrowser.element.findByText('options').rightClick();Send KeysYou can type values into input fields by using browser.element.find('selector').sendKeys('text'). Instead of passing text you can also pass an array of texts. To use key constants such as Enter or Space, you can use browser.keys.CONSTANT_NAME. You can find all key press constants here// Type in 'Nightwatch' into input field searchbrowser.element.findByPlaceholderText('search').sendKeys('Nightwatch');//or// Type in 'John Doe' into the username field and press enterbrowser.element.findByLabelText('username').sendKeys(['Nightwatch', browser.Keys.ENTER]);// Type in 'Nightwatch' into input field searchbrowser.element.findByPlaceholderText('search').sendKeys('Nightwatch');or// Type in 'John Doe' into the username field and press enterbrowser.element.findByLabelText('username').sendKeys(['Nightwatch', browser.Keys.ENTER]);Set ValueYou can set the value attribute of an element by using browser.element.find('selector').setValue('value').// Set the value of input field search as 'Nightwatch'browser.element.findByPlaceholderText('search').setValue('Nightwatch');// Set the value of input field search as 'Nightwatch'browser.element.findByPlaceholderText('search').setValue('Nightwatch');ClearYou clear the value of an element by using browser.element.find('selector').clear().// Clear the value of input field searchbrowser.element.find('#search').clear();// Clear the value of input field searchbrowser.element.find('#search').clear();Get element detailsYou can get details of elements by using the following methods Get text - browser.element.find('selector').getText()Get value - browser.element.find('selector').getValue()Get tag name - browser.element.find('selector').getTagName()Get attribute - browser.element.find('selector').getAttribute()Get CSS property - browser.element.find('selector').getCssProperty()Get ID - browser.element.find('selector').getId()Get Accessibility name - browser.element.find('selector').getAccessibilityName()Get rect - browser.element.find('selector').getRect()// Get the text of the headerbrowser.element.find('#header').getText();// Get the value of the input fieldbrowser.element.find('#input').getValue();// Get the tag name of an elementbrowser.element.findByRole('link').getTagName();// Get the style attribute of an elementbrowser.element.find('#element').getAttribute('style');// Get the background-color of an elementbrowser.element.find('#element').getCssProperty('background-color');// Get the id of an elementbrowser.element.find('#element').getId();// Get the accessibility name of an elementbrowser.element.find('#element').getAccessibilityName();// Get the rectangle bounding box of an elementbrowser.element.find('#element').getRect();// Get the text of the headerbrowser.element.find('#header').getText();// Get the value of the input fieldbrowser.element.find('#input').getValue();// Get the tag name of an elementbrowser.element.findByRole('link').getTagName();// Get the style attribute of an elementbrowser.element.find('#element').getAttribute('style');// Get the background-color of an elementbrowser.element.find('#element').getCssProperty('background-color');// Get the id of an elementbrowser.element.find('#element').getId();// Get the accessibility name of an elementbrowser.element.find('#element').getAccessibilityName();// Get the rectangle bounding box of an elementbrowser.element.find('#element').getRect();Set element detailsIn the previous section, you learnt how to fetch attributes of an element. You can also set values of an element with the following methodsSet text - browser.element.find('selector').setText('text')Set attribute - browser.element.find('selector').setAttributes('attribute', 'attribute value')// Set the text of header as 'Nightwatch'browser.element.find('#headeer').setText('Nightwatch');// Set the style of button as \"display:none;\"browser.element.find('#button').setAttribute('style','display:none;');// Set the text of header as 'Nightwatch'browser.element.find('#headeer').setText('Nightwatch');// Set the style of button as \"display:none;\"browser.element.find('#button').setAttribute('style','display:none;');GeolocationYou can use browser level method .setGeolocation() to simulate traffic from a particular latitude and longitude// Set the latitude & longitude of the prime meridianbrowser.setGeolocation({latitude: 51.4780, longitude: 0.0014, accuracy: 100})// Set the latitude & longitude of the prime meridianbrowser.setGeolocation({latitude: 51.4780, longitude: 0.0014, accuracy: 100})Custom commandsIf the existing Nightwatch commands do not suffice your needs or if you want to reduce some complex logic into a single command, you can even write your own custom commands. Refer to this guideRecommended next stepsNow that you understand selectors and commands,you can proceed towards understanding how assertions work with Nightwatch  Assertions\u2190BackSelectorsNext PageAssertions\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/commands.html"}, {"title": "Selectors", "body": "Selectors for websites & web appsOverviewThe 1st step towards writing any web interaction is to find an element. Selectors are needed to find the element from the DOM tree. With Nightwatch v3, the selectors have been upgraded to make it even more simpler to find elements. V3 also introduces chaining of .find() commands to be able to locate nested elements with ease.CSS SelectorsYou can easily find elements within the DOM tree using CSS selectors. There are multiple types of simple & complex CSS selectors that Nightwatch supports. Some common examples includeid basedclass basedelement class basednested// Find an element which contains id = element-idbrowser.element.find('#element-id');// Find all elements with CSS class activebrowser.element.findAll('.active');// Find all <p> elements with class activebrowser.element.find('p.active');// Find element with class active nested within an element with id listbrowser.element.find('#id > .active');// Find an element which contains id = element-idbrowser.element.find('#element-id');// Find all elements with CSS class activebrowser.element.findAll('.active');// Find all <p> elements with class activebrowser.element.find('p.active');// Find element with class active nested within an element with id listbrowser.element.find('#id > .active');XPath SelectorsXPath is a query language for selecting nodes from an XML document based on their location and properties. You can use XPaths to locate elements within the DOM tree. // Find an element with XPathbrowser.element.find(by.xpath('xpath string'))// Find all elements with XPathbrowser.element.findAll(by.xpath('xpath string'))We do not recommend the use of XPath selectors as it can break your tests frequentlyYou can learn more about XPath selectors out here.Text basedText based selectors are a very natural way of finding elements. // Find an element with text 'Sign In'browser.element.findByText('Sign In');// Find all elements with text 'Sign In'browser.element.findAllByText('Sign In');// Find an element with text 'Sign In'browser.element.findByText('Sign In');// Find all elements with text 'Sign In'browser.element.findAllByText('Sign In');Using text based selectors can be problematic if the website or web app has internationalizationPlaceholder text basedPlaceholder texts are common within form elements or search bars. Let's see how you can find elements which contain placeholder text 'Search here...'// Find the search bar with placeholder text 'Search here...'browser.element.findByPlaceholderText('Search here...');// Find all elements with placeholder text 'Enter here'browser.element.findAllByPlaceholderText('Enter here');// Find the search bar with placeholder text 'Search here...'browser.element.findByPlaceholderText('Search here...');// Find all elements with placeholder text 'Enter here'browser.element.findAllByPlaceholderText('Enter here');Alt text basedAlt texts are common with media within a page. You can easily find such elements with alt text based methods. // Find the element with alt text 'cat-image'browser.element.findByAltText('cat-image');// Find all elements with alt text 'cat-image'browser.element.findAllByAltText('cat-image');// Find the element with alt text 'cat-image'browser.element.findByAltText('cat-image');// Find all elements with alt text 'cat-image'browser.element.findAllByAltText('cat-image');Inputs based on labelsSometimes form inputs might not contain text or placeholder text, but might contain labels as shown belowYou can easily find the input element related to the label First Name by using label based methods// Find the input element associated with label 'First Name'browser.element.findByLabelText('First Name');// Find the input element associated with label 'First Name'browser.element.findByLabelText('First Name');Selecting nth elementIf you need to find an element at a specific index from a list of elements, Nightwatch provides a convenience method .nth// Find the 2nd element from all ul elementsbrowser.element.findAll('ul').nth(2);// Find the 2nd element from all ul elementsbrowser.element.findAll('ul').nth(2);Recommended next stepsNow that you understand selectors, you can use them to write commands & assertions.  CommandAssertions\u2190BackInstall NightwatchNext PageSelectors\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/selectors.html"}, {"title": "Assertions", "body": "Adding assertions to testsOverviewNightwatch provides built-in extendable assert/verify library as two namespaces containing the same methods that perform assertions on elements. .assertWith the .assert namespace, when an assertion fails, the test ends, thus skipping all other assertions in the test.The following example code snippet uses the assert namespace to assert whether an element with class non_existing is visible on the page. If the assertion fails, the test ends:    browser.element.find('selector').assert.visible('.non_existing');  .verifyWith the .verify namespace, when an assertion fails, the test logs the failure and continues with other assertions in the test.The following example code snippet uses the verify namespace to check whether an element with class non_existing is visible on the page. If the assertion fails, a failure is logged and the test continues: browser.verify.visible('.non_existing');Basic AssertionsThe methods from the Node.js assert module are also available on the .assert/.verify namespaces to be used as required.Negate (\".not\") AssertionsStarting Nightwatch version 1.3, all the assertions including custom-defined assertions have a \".not\" counterpart, which can be used to assert the opposite condition.Assertions such as, `elementNotPresent`, `cssClassNotPresent`, `hidden` are obsolete and deprecated.The following example code snippet shows the \".not\" assertions:tests/sampleTest.jsdescribe('Demo .not assertion', function() {  it('demo test', function(browser) {    browser.init();        browser      .element.find('.not_present')      .assert.not.elementPresent();        browser       .assert.not.urlContains('http://');        // ...  })})Automatic RetriesBy default, Nightwatch automatically retries failed assertions for up to 5000 milliseconds. This can be configured by setting the  retryAssertionTimeout (in milliseconds) property in your globals object in your nightwatch.json file. Check out working with test globals for more details.  If the given timeout is reached, the test runner stops retrying and marks the assertion as failed.The following example code snippet shows the retryAssertionTimeout property defined in the configuration file: nightwatch.conf.js{  src_folders: ['tests'],    test_settings: {    default: {      launch_url: 'https://nightwatchjs.org',            globals: {        myGlobalVar: 'some value',        retryAssertionTimeout: 5000      }    }  }}Expect assertionsIn addition to the assert namespace, the Nightwatch API supports out of the box a BDD-style expect assertion library which greatly improves the flexibility as well as readability of the assertions.The expect assertions use a subset of the Expect api from the Chai framework and at this point are available for elements, cookies, page title, and url.ExampleHere a basic example that uses various expect.element([...]) assertions: tests/sampleTest.jsmodule.exports = {  'Demo test Ecosia.org': function (browser) {    browser.url('https://www.ecosia.org/');        // expect element header to be present in 1000ms    expect(browser.element.find('header')).to.be.present.before(1000);        browser.end();  }};Expecting a specific elements countIn this example, the test is expecting that a specified number of elements exist on the page, using the expect.elements([...]).count assertion:  tests/sampleTest.jsmodule.exports = {  'demo test ecosia.org'(browser) {    browser      .url('https://www.ecosia.org/')      .expect(browser.element.findAll('section').count()).to.equal(5);  },    after(browser) {    browser.end();  }};The expect interface provides a much more flexible and fluid language for defining assertions, significantly improved over the existing assert interface. The only downside is that it's not possible to chain assertions anymore.For a complete list of available expect assertions, refer to the API docs.\u2190BackCommandsNext PageRun tests\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/adding-assertions.html"}, {"title": "BDD test syntax", "body": "BDD test syntaxOverviewStarting with Nightwatch version 1.3, you can use the popular BDD interfaces for writing tests. You don't need additional configuration to use BDD interfaces. These are now supported out of the box.You can also run tests written in BDD describe and Exports interfaces together. Prior to this version, you had to use the Mocha test runner for enabling this functionality, which is now possible without additional plugins or libraries. The BDD interface in Nightwatch provides the following functions:describe() / context()test() / it() / specify()before()after()beforeEach()afterEach()Nightwatch doesn't support nested describe`/`context declarations currently. You can only use describe to define the name for the test suite. Exampledescribe('Ecosia', function() {    // test() and specify() is also available    it('demo test', function(browser) {    browser      .url('https://www.ecosia.org/')      .setValue('input[type=search]', 'nightwatch')      .click('button[type=submit]')      .assert.containsText('.mainline-results', 'Nightwatch.js')      .end();  });});import {NightwatchTests} from 'nightwatch';const Ecosia: NightwatchTests = {  'demo test': () => {    browser      .url('https://www.ecosia.org/')      .setValue('input[type=search]', 'nightwatch')      .click('button[type=submit]')      .assert.containsText('.mainline-results', 'Nightwatch.js')      .end();  }};export default Ecosia;In addition to the usual BDD syntax, Nightwatch provides a few ways for defining own behaviour.Test suite-specific capabilitiesdescribe('homepage test with describe', function() {  // testsuite specific capabilities  this.desiredCapabilities = {    browserName: 'firefox'  };    it('...', function() {...});});Test suite-specific tagsdescribe('homepage test with describe', function() {  // defining tags using bdd  this.tags = ['login', 'authentication''];    it('...', function() {...});});Test suite-specific retriesdescribe('homepage test with describe', function() {  // how many time to retry a failed testcase inside this test suite   this.retries(3);      // how many times to retry the current test suite in case of an assertion failure or error   this.suiteRetries(2);      it('...', function() {...});});Complete BDD syntaxRetrieving settingsAll current settings are available via this.settings.describe('homepage test with describe', function() {  console.log('Settings', this.settings);    it('...', function() {    // ...  });});Desired capabilitiesTestsuite specific capabilities.describe('homepage test with describe', function() {  this.desiredCapabilities = {};    it('...', function() {    // ...  });});Unit testsEnable this if the current test is a unit/integration test (i.e. no Webdriver session will be created);describe('homepage test with describe', function() {   this.unitTest = true;      it('...', function() {     // ...   });});Ending the session on failSet this to false if you'd like the browser window to be kept open in case of a failure or error (useful for debugging).describe('homepage test with describe', function() {   this.endSessionOnFail = false      it('...', function() {     // ...   });});Skip rest of test cases on failSet this to false if you'd like the rest of the test cases/test steps to be executed in the event of an assertion failure/errordescribe('homepage test with describe', function() {   this.skipTestcasesOnFail = true      it('...', function() {     // ...   });});Disable/skip a test suiteSet this to true if you'd like this test suite to be skipped by the test runnerdescribe('homepage test with describe', function() {   this.disabled = true      it('...', function() {     // ...   });});Retriesdescribe('homepage test with describe', function() {  this.retries(3);  this.suiteRetries(2);    it('...', function() {    // ...    });});Control assertion timeoutControl the assertion and element commands timeout until when an element should be located or assertion passeddescribe('homepage test with describe', function() {  this.timeout(1000)    it('...', function() {    // ...  });});Control polling intervalControl the polling interval between re-tries for assertions or element commandsdescribe('homepage test with describe', function() {  this.retryInterval(100);    it('...', function() {    // ...  });});Define tagsDefine tags for this test suite.describe('homepage test with describe', function() {  this.tags = ['login']    it('...', function() {    // ...  });});Test functions and hooksdescribe('homepage test with describe', function() {    before(function(browser) {    this.homepage = browser.page.home();  });    it('startHomepage', () => {    this.homepage.navigate();    this.homepage.expect.section('@indexContainer').to.be.not.visible;  });      // Run only this testcase  //*  it.only('startHomepage', () => {    this.homepage.navigate();  });  *//     // skipped testcase: equivalent to: test.skip(), it.skip(), and xit()  xtest('async testcase', async browser => {    const result = await browser.getText('#navigation');    console.log('result', result.value)  });    test('version dropdown is enabled', browser => {    const navigation = this.homepage.section.navigation;    const navbarHeader = navigation.section.navbarHeader;        navbarHeader.expect.element('@versionDropdown').to.be.enabled;  });    after(browser => browser.end());});Example Github repoWe've put together a complete Github template repo with several examples which we're periodically updating, including a Github Actions workflow for you to get started with.  Recommended contentExports test syntaxUsing async/awaitFinding & interacting with DOM Elements\u2190BackConfigure AWS Device FarmNext PageExport test syntax\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/test-syntax-bdd.html"}, {"title": "Exports test syntax", "body": "Use 'exports' test syntaxOverviewNightwatch default interface for writing tests has been the exports syntax, which makes it very easy to write end-to-end tests. While this format is slightly easier to understand and work with, it is also more limited than the BDD describe() interface. Due to the widespread usage of describe() as a test format and compatibility with tools like Mocha, we recommend using the BDD describe(), however exports will also continue to work just fine.     ExampleThe following basic test suite example opens the search engine Ecosia.org, searches for the term nightwatch, and then verifies if the term first result is the Nightwatch.js website.tests/sampleTest.jsmodule.exports = {  'Demo test ecosia.org' : function(browser) {    browser      .url('https://www.ecosia.org/')      .waitForElementVisible('body')      .assert.titleContains('Ecosia')      .assert.visible('input[type=search]')      .setValue('input[type=search]', 'nightwatch')      .assert.visible('button[type=submit]')      .click('button[type=submit]')      .assert.containsText('.mainline-results', 'Nightwatch.js')      .end();  }};You can also include multiple steps in a test as follows:tests/sampleTest.jsmodule.exports = {  'step one: navigate to ecosia.org': function(browser) {    browser      .url('https://www.ecosia.org')      .waitForElementVisible('body')      .assert.titleContains('Ecosia')      .assert.visible('input[type=search]')      .setValue('input[type=search]', 'nightwatch')      .assert.visible('button[type=submit]');  },    'step two: click submit' : function (browser) {    browser      .click('button[type=submit]')      .assert.containsText('.mainline-results', 'Nightwatch.js')      .end();  }};Using ES Modules (ESM)If using ES Modules in your project, you'll need to write your tests using the below format: tests/sampleTest.jsexports default {  'Demo test ecosia.org' : function(browser) {    browser      .url('https://www.ecosia.org/')      .waitForElementVisible('body')      .assert.titleContains('Ecosia')      .assert.visible('input[type=search]')      .setValue('input[type=search]', 'nightwatch')      .assert.visible('button[type=submit]')      .click('button[type=submit]')      .assert.containsText('.mainline-results', 'Nightwatch.js')      .end();  }};You'll also need to use nightwatch.conf.cjs config file.We've put together a complete Github ESM template repo with several examples which we're periodically updating, including a Github Actions workflow for you to get started with.Test tagsYou can also selectively target tests to run based on tags, such that a test may belong to multiple tags. For example, you might have a login test that belongs to a login suite as well as a sanity suite.The tagging can be accomplished by adding the @tags property to a test module:tests/sampleTest.jsmodule.exports = {  '@tags': ['login', 'sanity'],  'demo login test': function (browser) {     // test code  }};To select which tags to run, use the --tag command line flag:nightwatch --tag loginSpecify multiple tags as:nightwatch --tag login --tag something_elseTo skip running tests with a specific tag, use the `--skiptags` flag:nightwatch --skiptags loginOr to skip multiple tags, add each tag you want to skip as comma-separated:nightwatch --skiptags login,something_elseRecommended contentBDD test syntaxUsing async/await\u2190BackBDD test syntaxNext PageUse ES6 async/await\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/test-syntax-exports.html"}, {"title": "ES6 async/await", "body": "Using ES6 async/awaitOverviewStarting with Nightwatch version 1.1, you can write tests as an ES6 async function.The async function enables the API commands to return a promise and makes it possible to use the await operator to retrieve the result, instead of the callback, as it is by default.Use of async function greatly improves the readability and ease of writing of tests. Starting Nightwatch version 1.7, chaining the API commands when using an async function is also supported.Exampletests/exampleTest.jsmodule.exports = {  'demo test async': async function (browser) {    // get the available window handles    const result = await browser.windowHandles();    console.log('result', result);        // switch to the second window    // await is not necessary here since we're not interested in the result    browser.switchWindow(result.value[1]);  }};Using Callbacks with asyncCallbacks can still be used as before and if the callback returns a Promise, the result of the promise is the result of the command as shown in the following exammple code:tests/exampleTest.jsmodule.exports = {  'demo test async': async function (browser) {    // get the available window handles    const value = await browser.windowHandles(function(result) {      // we only want the value, not the entire result object      return Promise.resolve(result.value);    });        console.log('value', value);        // switch to the second window    browser.switchWindow(value[1]);  }};Recommended contentWriting tests > BDD describe test syntaxWriting tests > Exports test syntaxFinding & interacting with DOM Elements\u2190BackExports test syntaxNext PageFind & interact with DOM elements\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/using-es-6-async-await.html"}, {"title": "Finding DOM elements", "body": "Finding & interacting with DOM ElementsOverviewFinding elements on a page is by far one of the most common and critical functions during an end-to-end test. Nightwatch provides several techniques of locating elements and also an extensible assertion framework to perform verifications on them. Elements are searched for from the document root, using either a CSS selector or an XPath selector. You can also use other locator strategies. Check out the Webdriver documentation for more information.Elements are internally identified using a unique web element reference id. When interacting with elements, Nightwatch manages this step of identifying the IDs internally and uses its automatic retry mechanisms for locating the element before interacting with it or performing any assertions.Element RetriesWhen interacting with elements, Nightwatch polls the DOM for a configurable duration when trying to find any element. If the element is not found, a NoSuchElementError error is thrown. ExampleIn the following example, the setValue command internally performs the element lookup, and then calls the element that is set in the setValue command.tests/sampleTest.jsmodule.exports = {  'Demo test ecosia.org': function (browser) {    browser      .url('https://www.ecosia.org/')      .setValue('input[type=search]', 'nightwatch')      .click('button[type=submit]')      .assert.containsText('.mainline-results', 'Nightwatch.js')      .end();  }};import {NightwatchTests} from 'nightwatch';const ecosiaTest: NightwatchTests = {'Demo test ecosia.org': () => {  browser    .url('https://www.ecosia.org/')    .setValue('input[type=search]', 'nightwatch')    .click('button[type=submit]')    .assert.containsText('.mainline-results', 'Nightwatch.js')    .end();},export default ecosiaTest;Relative locatorsThese locators are helpful when it is not easy to construct a locator for the required element, but easy to describe spatially where the element is in relation to another element that does have an easily constructed locator.If you want to find the password field that exists below the username field, you would use the following example:module.exports = {  'Demo test ecosia.org': function (browser) {    const passwordElement = locateWith(By.tagName('input')).below(By.css('input[type=email]'));        browser      .navigateTo('https://archive.org/account/login')      .setValue(passwordElement, 'password')      .assert.valueEquals('input[type=password]', 'password');  }};import {NightwatchTests} from 'nightwatch';const ecosiaTest: NightwatchTests = {'Demo test ecosia.org': () => {  const passwordElement = locateWith(By.tagName('input')).below(By.css('input[type=email]'));    browser    .navigateTo('https://archive.org/account/login')    .setValue(passwordElement, 'password')    .assert.valueEquals('input[type=password]', 'password');},export default ecosiaTest;Apart from the commands from the example, you can also use the following commands:abovebelowtoRightOftoLeftOfnearChaining Relative LocatorsFor some complex layouts, such as, where an element might exist above and to the right of the starting element, you can chain relative locators as shown in the following example code snippet:locateWith(By.tagName('button'))  .below(By.id('email')  .toRightOf(By.css('#cancel')));Element PropertiesAn element can also be specified as an object if greater flexibility in locating and interacting with elements is required. The object definition must contain at least the selector property. Apart from the selector property, you can use any of the following properties: selector - the element selector name (e.g.: '#input-element')locateStrategy - e.g. 'css selector'index - used to target a specific element in a query that results in multiple elements returned. Normally, only the first element is used (index = 0) but using the index property, you can specify any element within the result. abortOnFailure - used to overwrite this setting when using waitForElement* commandstimeout - used to overwrite the default timeout for when using waitForElement* commands or assertionsretryInterval - used to overwrite the default retry interval for when using waitForElement* commands or assertionssuppressNotFoundErrors - Some element commands like .click() or .getText() will throw a NoSuchElement error if the element cannot be located, causing the test to fail. If this option is set to true then this error is ignored.In the earlier example, the input[type=search] element selector returns 3 elements. If you are want to use the second element, see the following example code snippet:module.exports = {  'Demo test ecosia.org': function (browser) {    browser.setValue({selector: 'input[type=search]', index: 1}, 'nightwatch')  }};import {NightwatchTests} from 'nightwatch';const ecosiaTest: NightwatchTests = {'Demo test ecosia.org': () => {  browser.setValue({selector: 'input[type=search]', index: 1}, 'nightwatch');},Recommended contentBDD test syntaxUsing async/await\u2190BackUse ES6 async/awaitNext PageAdd assertions\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/finding-interacting-with-dom-elements.html"}, {"title": "Xpath selectors", "body": "Find an element by XpathOverviewXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of finding elements in a web page.Nightwatch supports XPath selectors in locating elements. CSS selectors are used by default if no strategy is specified, and there are several ways in which to make use of XPath, depending on the use case:1. Using .useXpath() commandUsing useXpath() command, as seen in the example below, is a convenient way. You don't need to bother with using multiple parameters on element commands, or you may have more than one subsequent element commands/assertions in the same test which use XPath expressions. To switch back to CSS, call useCss().tests/sampleTest.jsmodule.exports = {  demoTest: function (browser) {    browser      .useXpath() // every selector now must be xpath      .click(\"//tr[@data-recordid]/span[text()='Search Text']\")      .useCss() // we're back to CSS now      .setValue('input[type=text]', 'nightwatch')  }};2. Find elements with Xpath selectorsYou can also use Xpath directly on a single command or assertion, by either passing an element selector object, or specifying 'xpath' strategy as first argument:tests/sampleTest.jsmodule.exports = {  demoTest(browser) {    // using element selector objects    browser.click({      selector: '//tr[@data-recordid]/span[text()='Search Text']',      locateStrategy: 'xpath'    });        // specifying xpath strategy as first argument    browser.click('xpath', '//tr[@data-recordid]/span[text()='Search Text']');}};3. Always use XPath by defaultIf you mostly are using XPath expressions and you want to avoid configuring the strategy in your tests all the time, you can also use XPath by default by setting the property use_xpath: true in your config.nightwatch.json{  \"use_xpath\": true}\u2190BackAdd assertionsNext PageWrite complex user actions\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/using-xpath-selectors.html"}, {"title": "Complex user actions", "body": "Write complex user actionsOverviewNightwatch 2 brings support for working with the newer Actions API from Selenium WebDriver for performing complex user gestures.The Actions API provides granular control over exactly what designated input devices can do. Selenium provides an interface for 3 kinds of input sources: a key input for keyboard devicesa pointer input for a mouse, pen or touch deviceswheel inputs for scroll wheel devices (introduced in Selenium 4.2)More information is available on the W3C Webdriver spec page.ExampleThe new API is available and ready to use in Nightwatch via the existing .perform() command. The previous functionality of the perform() command is still there and working in the same way as before.tests/sampleTest.jsdescribe('user actions api', function() {    it('demo test', function() {    browser      .navigateTo('https://nightwatchjs.org')      .perform(function() {        const actions = this.actions({async: true});                return actions         .keyDown(Keys.SHIFT)         .keyUp(Keys.SHIFT);      });  })})Available Actions.clear()Releases all keys, pointers, and clears internal state.Parameters:None.click([element])Short-hand for performing a simple left-click (down/up) with the mouse.Parameters:NameTypedescriptionelementOptionalWebElementIf specified, the mouse will first be moved to the center of the element before performing the click..contextClick([element])Short-hand for performing a simple right-click (down/up) with the mouse.Parameters:NameTypedescriptionelementOptionalWebElementIf specified, the mouse will first be moved to the center of the element before performing the click..doubleClick([element])Short-hand for performing a double left-click with the mouse.Parameters:NameTypedescriptionelementOptionalWebElementIf specified, the mouse will first be moved to the center of the element before performing the click..dragAndDrop(from, to)Configures a drag-and-drop action consisting of the following steps:    Move to the center of the from element (element to be dragged).Press the left mouse button.If the to target is a WebElement, move the mouse to its center. Otherwise, move the mouse by the specified offset.Release the left mouse button.Parameters:NameTypedescriptionfromWebElementThe element to press the left mouse button on to start the dragtoWebElement or: {x: number, y: number}Either another element to drag to (will drag to the center of the element), or an object specifying the offset to drag by, in pixels..insert(device, ...actions)Appends actions to the end of the current sequence for the given device. If device synchronization is enabled, after inserting the actions, pauses will be inserted for all other devices to ensure all action sequences are the same length.Parameters:NameTypedescriptiondeviceDevicethe device to updateactions...Actionthe actions to insert..keyDown(key)Inserts an action to press a single key.Parameters:NameTypedescriptionkeystring|numberthe key to press. This key may be specified as a Key value, a specific unicode code point, or a string containing a single unicode code point..keyUp(key)Inserts an action to release a single key.Parameters:NameTypedescriptionkeystring|numberthe key to release. This key may be specified as a Key value, a specific unicode code point, or a string containing a single unicode code point..keyboard()Parameters:NoneReturns:TypedescriptionKeyboardthe keyboard device handle..mouse()Parameters:NoneReturns:TypedescriptionPointerthe mouse pointer device handle..move([options])Inserts an action for moving the mouse x and y pixels relative to the specified origin. The origin may be defined as the mouse's current position, the viewport, or the center of a specific WebElement.It's possible to adjust how long the browser driver should take, in milliseconds, to perform the move using the duration parameter (defaults to 100 ms).Parameters:NameTypedescriptionoptionsOptional ObjectThe move options. Defaults to moving the mouse to the top-left corner of the viewport over 100ms. Available values are:{  duration: {Number|undefined},   origin: (Origin|WebElement|undefined),   x: {Number|undefined},   y: {Number|undefined}}.pause(duration, ...devices)Inserts a pause action for the specified devices, ensuring each device is idle for a tick. The length of the pause (in milliseconds) may be specified as the first parameter to this method (defaults to 0). Otherwise, you may just specify the individual devices that should pause.If no devices are specified, a pause action will be created (using the same duration) for every device.Parameters:NameTypedescriptiondurationOptional Number|DeviceThe length of the pause to insert, in milliseconds. Alternatively, the duration may be omitted (yielding a default 0 ms pause), and the first device to pause may be specified.devices...DeviceThe devices to insert the pause for. If no devices are specified, the pause will be inserted for all devices..press([button])Inserts an action to press a mouse button at the mouse's current location.Parameters:NameTypedescriptionbuttonOptional ButtonThe button to press; defaults to LEFT..release([button])Inserts an action to release a mouse button at the mouse's current location.Parameters:NameTypedescriptionbuttonOptional ButtonThe button to release; defaults to LEFT..sendKeys(...keys)Inserts a sequence of actions to type the provided key sequence. For each key, this will record a pair of keyDown and keyUp actions. Parameters:NameTypedescriptionkeys...String|NumberThe keys to type..synchronize(...devices)Ensures the action sequence for every device referenced in this action sequence is the same length. For devices whose sequence is too short, this will insert pauses so that every device has an explicit action defined at each tick.Parameters:NameTypedescriptiondevices...DeviceThe specific devices to synchronize. If unspecified, the action sequences for every device will be synchronized.Working with Action TicksAction sequences are divided into a series of \"ticks\". At each tick, the browser driver will perform a single action for each device included in the action sequence. At tick 0, the driver will perform the first action defined for each device, at tick 1 the second action for each device, and so on until all actions have been executed. If an individual device does not have an action defined at a particular tick, it will automatically pause.By default, action sequences will be synchronized so only one device has a define action in each tick. Consider the following code sample:tests/sampleTest.jsdescribe('user actions api', function() {    it('demo test', function() {    browser      .perform(function() {        const actions = this.actions({async: true});                return actions          .keyDown(Keys.SHIFT)          .move({origin: el})          .press()          .release()          .keyUp(Keys.SHIFT);      });    })})This produces the following sequence of ticks:DeviceTick 1Tick 2Tick 3Tick 4Tick 5KeyboardkeyDown(SHIFT)pause()pause()pause()keyUp(SHIFT)Mousepause()move({origin: el})press()release()pause()Recommended contentSelenium API DocsWebdriver W3C spec\u2190BackUse Xpath selectorsNext PageUse CucumberJS\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/write-complex-user-actions.html"}, {"title": "Test hooks", "body": "Using test hooksNightwatch provides the standard before/after and beforeEach/afterEach hooks to be used in the tests.before, beforeEach, after, afterEachThe before and after will run before and after the execution of the test suite respectively, while beforeEach and afterEach are ran before and after each testcase (test step).All methods have the Nightwatch instance passed as argument.Example:module.exports = {  before : function(browser) {    console.log('Setting up...');  },    after : function(browser) {    console.log('Closing down...');  },    beforeEach : function(browser) {      },    afterEach : function(browser) {      },    'step one' : function (browser) {    browser     // ...  },    'step two' : function (browser) {    browser    // ...      .end();  }};In the example above the sequence of method calls will be as follows: before(), beforeEach(), \"step one\", afterEach(), beforeEach(), \"step two\", afterEach(), after().Asynchronous before[Each] and after[Each]All the before[Each] and after[Each] methods can also perform asynchronous operations, in which case they will require the callback passed as the second argument.The done function must be called as the last step when the async operation completes. Not calling it will result in a timeout error.Example with beforeEach & afterEach:module.exports = {  beforeEach: function(browser, done) {    // performing an async operation    setTimeout(function() {      // finished async duties      done();    }, 100);  },    afterEach: function(browser, done) {    // performing an async operation    setTimeout(function() {      // finished async duties      done();    }, 200);  }};Controlling the done invocation timeoutBy default the done invocation timeout is set to 10 seconds (2 seconds for unit tests). In some cases this might not be sufficient and to avoid a timeout error, you can increase this timeout by defining an asyncHookTimeout property (in milliseconds) in your external globals file (see below for details on external globals).For an example, refer to the provided globalsModule example.Explicitly failing the testFailing the test intentionally in a test hook can be achieved by calling done with an Error argument:module.exports = {  afterEach: function(browser, done) {    // performing an async operation    performAsync(function(err) {      if (err) {        done(err);        return;      }      // ...    });  }};Global Test HooksThe same set of test hooks as per test suite is also available globally, outside the scope of the test. Refer to the next section for details.\u2190BackUse Mocha as a test runnerNext PageUse test globals\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/using-test-hooks.html"}, {"title": "Test globals", "body": "Using test globalsAnother useful concept that Nightwatch provides is test globals. In its most simple form, it is a dictionary of name-value pairs which is defined in your configuration file.Globals can be defined either as a \"globals\" property or as an external file which is specified as the \"globals_path\" property.Here's an example definition using the \"globals\" property in nightwatch.json:nightwatch.conf.js{  \"src_folders\": [],  \"globals\": {    \"myGlobalVar\" : \"some value\",    \"otherGlobal\" : \"some other value\"  },  \"test_settings\": {    \"default\": {      \"launch_url\": \"https://nightwatchjs.org\",    }  }}Like the launch_url property, the globals object is made available directly on the Nightwatch api which is passed to the tests.tests/sampleTest.jsmodule.exports = {  'Demo test' : function (browser) {    console.log(browser.globals.myGlobalVar); // myGlobalVar == \"some value\"  }};Pre-defined GlobalsThe following global properties can be used to control the behaviour of the test runner and are defined with the following default values:nightwatch/globals.jsmodule.exports = {  // this controls whether to abort the test execution when an assertion failed and skip the rest  // it's being used in waitFor commands and expect assertions  abortOnAssertionFailure: true,  // this will overwrite the default polling interval (currently 500ms) for waitFor commands  // and expect assertions that use retry  waitForConditionPollInterval: 500,  // default timeout value in milliseconds for waitFor commands and implicit waitFor value for  // expect assertions  waitForConditionTimeout : 5000,  // since 1.4.0 \u2013 this controls whether to abort the test execution when an element cannot be located; an error  // is logged in all cases, but this also enables skipping the rest of the testcase;  // it's being used in element commands such as .click() or .getText()  abortOnElementLocateError: false,    // this will cause waitFor commands on elements to throw an error if multiple  // elements are found using the given locate strategy and selector  throwOnMultipleElementsReturned: false,  // By default a warning is printed if multiple elements are found using the given locate strategy  // and selector; set this to true to suppress those warnings  suppressWarningsOnMultipleElementsReturned: false,  // controls the timeout value for async hooks. Expects the done() callback to be invoked within this time  // or an error is thrown  asyncHookTimeout : 10000,  // controls the timeout value for when running async unit tests. Expects the done() callback to be invoked within this time  // or an error is thrown  unitTestsTimeout : 2000,  // controls the timeout value for when executing the global async reporter. Expects the done() callback to be   // invoked within this time or an error is thrown  customReporterCallbackTimeout: 20000,  // Automatically retrying failed assertions - You can tell Nightwatch to automatically retry failed assertions   // until a given timeout is reached, before the test runner gives up and fails the test.  retryAssertionTimeout: 5000,  // Custom reporter  reporter: function(results, done) {    // do something with the results    done(results);  }}Environment Specific GlobalsLike other test settings, globals have the ability to be overwritten per test environment. Consider this configuration:nightwatch.json{  \"src_folders\": [],  \"test_settings\": {    \"default\": {      \"launch_url\": \"https://nightwatchjs.org\",      \"globals\": {        \"myGlobalVar\" : \"some value\",        \"otherGlobal\" : \"some other value\"      }    },    \"integration\": {      \"globals\": {        \"myGlobalVar\" : \"integrated global\"      }    }  }}If we still pass the --env integration option to the runner, then our globals object will look like below:nightwatch --env integrationmodule.exports = {  'Demo test' : function (browser) {    console.log(browser.globals.myGlobalVar); // myGlobalVar == \"integrated global\"  }};\u2190BackUse test hooksNext PageUse global hooks\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/using-test-globals.html"}, {"title": "Global hooks", "body": "Global Test HooksThe same set of hooks as per test suite is also available globally, outside the scope of the test. In the case of global hooks, the beforeEach and afterEach refers to a test suite (i.e. test file), and are ran before and after a test suite.Global before[Each] and after[Each]You can also have global before and after [asynchronous] methods that can perform an operation before starting the test runner and right before exiting, when all the tests have finished executing.Similarly, global beforeEach and afterEach will be invoked before and after each test suite (i.e. test file). These ones do receive the Nightwatch browser object.The methods are defined in the external globals file and invoked using the globals object as context. The callback is the only argument passed and must be called when the operation finishes.Example:module.exports = {  'default' : {    isLocal : true,  },    'integration' : {    isLocal : false  },    // External before hook is ran at the beginning of the tests run, before creating the Selenium session  before(done) {    // run this only for the local-env    if (this.isLocal) {      // start the local server      App.startServer(function() {        // server listening        done();      });    } else {      done();    }  },    // External after hook is ran at the very end of the tests run, after closing the Selenium session  after(done) {    // run this only for the local-env    if (this.isLocal) {      // stop the local server      App.stopServer(function() {        // shutting down        done();      });    } else {      done();    }  },    // This will be run before each test suite is started  beforeEach(browser, done) {    // getting the session info    browser.status(function(result) {      console.log(result.value);      done();    });  },    // This will be run after each test suite is finished  afterEach(browser, done) {    console.log(browser.currentTest);    done();  },    // Called right after the command .navigateTo() is finished  async onBrowserNavigate(browser) {    return Promise.resolve();  },    // Called right before the command .quite() is finished  async onBrowserQuit(browser) {    return Promise.resolve();};  }\u2190BackUse test globalsNext PageAccessibility testing\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/global-test-hooks.html"}, {"title": "Accessibility testing", "body": "Accessibility (A11y) testing in NightwatchOverviewIn a bid to standardise accessibility testing, W3C has released the Web Content Accessibility Guidelines (WCAG) to standardise the practice of making websites inclusive to all. Since v2.3, accessibility testing support is now built-in to Nightwatch, using the aXe-core package developed by Deque Systems. Accessibility tests audit the rendered DOM against a set of heuristics based on WCAG rules and other industry-accepted best practices.The aXe library has over 90 different around accessibility testing and automatically catches up to 57% of WCAG issues.Run all rulesUse the command .axeInject() to inject the aXe library first and the simply run all accessibility tests with axeRun() command as shown below:describe('accessibility testing', function() {    it('run all accessibility rules', function(browser) {    browser      .navigateTo('https://www.w3.org/WAI/demos/bad/after/home.html')      .axeInject()      .axeRun('body');  });});Run selected rulesAlternatively, you can choose to run only a selected tests, by passing the rule IDs in an array as shown below:describe('accessibility testing', function() {    it('accessibility rule subset', function(browser) {    browser      .navigateTo('https://www.w3.org/WAI/demos/bad/after/home.html')      .axeInject()      .axeRun('body', {        runOnly: ['color-contrast', 'image-alt'],      });  });});Disable selected rulesYou can also choose to run all the tests and exclude a few tests.describe('accessibility testing', function() {    it('accessibility rule subset', function(browser) {    browser      .navigateTo('https://www.w3.org/WAI/demos/bad/after/home.html')      .axeInject()      .axeRun('body', {        rules: {            'color-contrast': {                enabled: false            },            'region': {                enabled: false            }        }    });  });});You can find the complete list of the rule IDs on the Axe Github page Recommended contentAPI Reference: axeInject()API Reference: axeRun()\u2190BackGlobal Test HooksNext PageVisual testing\u2192", "url": "https://nightwatchjs.org/guide/using-nightwatch/accessibility-testing.html"}, {"title": "Visual regression testing", "body": "Visual Regression Testing (VRT) using NightwatchOverviewVisual Regression Testing (VRT) is a type of software testing technique that compares screenshots or images of a user interface before and after changes have been made to the application. The goal of VRT is to detect unintended visual changes that may have been introduced during development, such as changes to layout, colour, typography, or other visual elements.Visual Regression Testing typically involves the following steps:Capture screenshots of the application or webpage before and after changes have been made.Compare the screenshots pixel-by-pixel to identify any differences.Review and analyse the differences to determine whether they are intentional or unintentional.Approve changes if they are intentionalHow does it work?Nightwatch uses JIMP, a Javascript image processing library with no native dependencies, to do the image comparison.Nightwatch logic:Waits for the elements to be presentTakes a screenshotCompares screenshot with baselineDisplays visual differences between the current screenshots and baseline in the VRT reportInstallationStep 1Install the plugin with this command: npm i @nightwatch/vrt --save-devStep 2Update the Nightwatch configuration to add the plugin to the listnightwatch.conf.jsmodule.exports = {  plugins: ['@nightwatch/vrt']  // other nightwatch settings...}Write visual regression testsIn order to use nightwatch-vrt, you only need to invoke the screenshotIdenticalToBaseline assertion and pass a css selector for the DOM element to compare. You may also pass a custom filename, visual_regression_settings overrides, and a custom log message.The screenshotIdenticalToBaseline takes 4 parameters as an input:selector - Identifies the element that will be captured in the screenshotfileName - Optional file name for this screenshot; defaults to the selectorsettings - Optional settings to override the defaults and visual_regression_settingsmessage - Optional message for nightwatch to log upon completionE.g.:vrt-demo.jsdescribe('VRT demo test', function() {    it('Test Google UI loads correctly', function(browser) {        browser            .navigateTo('https://www.google.co.uk')            .assert.screenshotIdenticalToBaseline('body',  /* Optional */ 'custom-name', {threshold: 0.0}, 'VRT custom-name complete.')            .end()    })})The first time a test is run, a baseline screenshot will be created and stored on disk. You should always register the baseline screenshot. Further executions of this test will compare against this baseline.Visual Regression SettingsNightwatch VRT ships with carefully thought through default settings. Here is the list: generate_screenshot_path default none - Passed function that will generate a screenshot pathlatest_screenshots_path default \"vrt/latest\" - Path to the most recently captured screenshotslatest_suffix default \"\" - A string appended to the end of the latest captured screenshotbaseline_screenshots_path default \"vrt/baseline\" - Path to the baseline expected screenshotsbaseline_suffix default \"\" - A string appended to the end of the baseline screenshotdiff_screenshots_path default \"vrt/diff\" - Path to the diff image of the two screenshotsdiff_suffix default  \"\" - A string appended to the end of the diff imagethreshold default 0.0 - Matching threshold, ranges from 0 to 1. Smaller values make the comparison more sensitiveprompt default false - If true, the user will be prompted to override baseline screenshot when the recently captured screenshot differsupdateScreenshots default false - If true, recently captured screenshots will always override the baselineHowever, these can be overridden globally via nightwatch.conf.js as shown below:nightwatch.conf.jsmodule.exports = {    //... other config    '@nightwatch/vrt': {    latest_screenshots_path: 'vrt/latest',    latest_suffix: '',    baseline_screenshots_path: 'vrt/baseline',    baseline_suffix: '',    diff_screenshots_path: 'vrt/diff',    diff_suffix: '',    threshold: 0.00,    prompt: false,    updateScreenshots: false  },}Further the settings can also be overridden passing as a JSON object (settings argument) as shown in the example as part of the screenshotIdenticalToBaseline assertion. Settings passed as a function argument will override the ones in the config file & default values.ReviewOnce the test-run is complete, a report would be generated. Under the vrt-report folder. You can either open it manually or use --open with the run test command to open the report automatically.Baseline & DiffThis shows how the baseline image and along with the diff. Every pixel that did not match is marked as red in the diff image. As you can notice, the diff % is also shown. If the diff% is less than the threshold, VRT engine will not mark the test as failed. Baseline & LatestThis shows how the current image differs from the baseline image.ApproveOnce you have reviewed that all visual changes are intentional, you can update the baseline by using the --update-screenshots flag. This is important as all further comparisons will happen against the new baseline.E.g.: npx nightwatch <path to tests> --update-screenshots\u2190BackAccessibility testingNext PageAPI testing\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/visual-regression-testing.html"}, {"title": "API testing", "body": "API Testing in NightwatchOverviewAPI testing is a type of software testing that involves testing the API layer of an application.API testing involves testing the requests and responses between the client application and the server. This is typically done by sending HTTP requests to the API endpoints and verifying the responses returned. The main goal of API testing is to ensure that the API behaves as expected, and that it returns the correct data and errors for different input scenarios.Overall, API testing is an important aspect of software testing that ensures the reliability and functionality of an application's API layer, enabling developers to build robust and scalable software applications.How does it work?To perform API testing, the official @nightwatch/apitesting plugin needs to be installed. The plugin provides the following features:Integration with supertest for testing HTTP requestsBuilt-in mock server based on express with support for sinon assertions on mocked HTTP requestsRequires Nightwatch 2.6.4 or higher.Installation1) Install the plugin from NPMnpm i @nightwatch/apitesting --save-dev2) Add the plugin to the listUpdate the Nightwatch configuration to add the plugin to the list:nightwatch.conf.jsmodule.exports = {  plugins: ['@nightwatch/apitesting']    // other Nightwatch settings...}3) Disable the browser sessionWe also need to turn off the browser session, since we're only doing API testing. This can be accomplished by adding a new environment for API testing as shown below in nightwatch.conf.jsnightwatch.conf.jsmodule.exports = {  // ....  api_testing: {    start_session: false,    webdriver: {      start_process: false,    }  }}Config settingsThe plugin has for now only one configuration option, which is weather or not to log the HTTP responses to the console. This can be configured in the nightwatch.json (or nightwatch.conf.js) config file:nightwatch.conf.js{  \"@nightwatch/apitesting\" : {    \"log_responses\": true  }}Test API headers & responsesSince Nightwatch use supertest under the hood, you can test different types of REST API headers & response.GET REQUESTget-api-test.jsdescribe('api testing', function () {  it('get api test', async function({supertest}) {    await supertest      .request(\"https://petstore.swagger.io/v2\")      .get(\"/pet/findByStatus?status=available\")      .expect(200)      .expect('Content-Type', /json/)      .then(function(response){          expect(response._body.length).to.be.greaterThan(0);      });  });});POST REQUESTpost-api-test.jsdescribe('api testing', function () {  it('post api test', async function({supertest}) {    await supertest      .request(\"https://petstore.swagger.io/v2\")      .post(\"/pet\")      .send({        \"id\": 0,        \"category\": {          \"id\": 0,          \"name\": \"string\"        },        \"name\": \"doggie\",        \"photoUrls\": [          \"string\"        ],        \"tags\": [          {            \"id\": 0,            \"name\": \"string\"          }        ],        \"status\": \"available\"      })      .expect(200)      .expect('Content-Type', /json/)      .then(function(response){          expect(response._body.name).to.be.equal(\"doggie\");      });  });});Running API testsEnsure that the API tests are run against an environment where the start_session and webdriver -> start_process are set to false.npx nightwatch <path to tests> --env api_testingHTML ReportOnce the tests are run, the results can be reviewed in the HTML report.Integrated mock serverThe @nightwatch/apitesting plugin also provides a built-in mock server based on express that can be used to assert incoming http requests.Here's a sample mock server:mock-server.jsdescribe('api testing with supertest in nightwatch POST', function () {    let server;    before(async function(client) {    server = await client.mockserver.create();    server.setup((app) => {      app.post('/api/v1/datasets/', function (req, res) {        res.status(200).json({          id: 'test-dataset-id'        });      });    });        await server.start(3000);  });    after(() => {    server.close();  });    it('demo test', async function(client) {    const req = await server.request()      .post('/api/v1/datasets/')      .send({name: 'medea'})      .set('Accept', 'application/json')      .expect(200)      .expect('Content-Type', /json/);        await client.assert.deepStrictEqual(server.route.post('/api/v1/datasets/').requestBody, {name: 'medea'});  });  });Mock server APIconst mockServer = await client.mockserver.create() \u2013 creates a new mock server instanceawait mockServer.setup(definition) \u2013 setup an existing mock server instance with the provided route definitionExample:await mockServer.setup((app) => {    app.get('/api/v1/schemas', function (req, res) {      console.log('GET /api/v1/schemas called');            res.status(200).json([        {          id: 'test-schema-id1'        },        {          id: 'test-schema-id2'        }      ]);    })  });await mockServer.start(port) \u2013 starts an existing mock server instance on the specified portawait mockServer.route(path) \u2013 returns a sinon spy on the specified routeAssert on incoming requestsUse the mockServer.route(path) method to retrive a spy on the specified route. You can then use the sinon assertions to assert on the incoming requests.ExampleConsider the previous mock server setup example. If we want to assert that the GET /api/v1/schemas route was called, we can do the following:it('demo test', async function(client) {    client      .assert.strictEqual(mockServer.route.get('/api/v1/schemas').calledOnce, true, 'called once')      .assert.strictEqual(mockServer.route.get('/api/v1/schemas').calledTwice, false);  });Assert on request headersWe can also assert on the request headers, for example using the built-in expect() assertions API which uses on chai:it('demo test', async function(client) {    const {requestHeaders} = mockServer.route.get('/api/v1/schemas');        client.expect(requestHeaders).to.have.property('connection', 'close');  });Assert on incoming post dataWe can also assert on the incoming post data:First, set up a post route for the mock server:await mockServer.setup((app) => {  app.post('/api/v1/datasets/', function (req, res) {    res.status(200).json({      id: 'test-dataset-id'    });  });});Then use the mockServer.route.post(path) method to retrive a spy on the specified route. You can then use the sinon assertions to assert on the incoming requests.it('demo test', async function(client) {    const {requestBody} = mockServer.route.post('/api/v1/schemas');        await client.assert.deepStrictEqual(requestBody, {name: 'medea'});});For waiting for incoming requests tests, you can use the waitUntil() command.Example using waitUntil:it('demo test', async function(client) {    const timeoutMs = 15000;    const retryIntervalMs = 500;        await client.waitUntil(async function () {      const spy = server.route.get('/api/v1/schemas');            if (spy) {        return spy.calledOnce;      }            return false;    }, timeoutMs, retryIntervalMs, new Error(`time out reached (10000ms) while waiting for API call.`));    });\u2190BackVisual TestingNext PageUnit & integration testing\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/api-testing.html"}, {"title": "Unit & integration testing", "body": "Writing Unit Tests with NightwatchOverviewUnit testing in Nightwatch has been available since version 0.9 and unit tests written in Nightwatch are also fully compatible with Mocha's Exports interface, so you can use either test runners.Unit Tests ModeNightwatch automatically attempts to connect to the WebDriver server and create a session. When running unit tests this needs to be disabled and the runner needs to be made aware that it is operating in unit testing mode.This can be done in two ways:1. Setting unit_tests_mode=trueThis is a global option. Set the unit_tests_mode option to true in the nightwatch.json:{  \"src_folders\" : [\"tests\"],    \"unit_tests_mode\": true}2. Adding @unitTest property per testYou can set the @unitTest property to true if you'd like to have individual test suites as unit tests.tests/sampleTest.jsconst assert = require('assert');module.exports = {  '@unitTest': true,    'demo UnitTest' : function (done) {    assert.equal('TEST', 'TEST');    setTimeout(function() {      done();    }, 10);  }};Choose an assertion frameworkFor unit tests, the browser object is not passed as an argument to the test case. The only argument passed is the done callback to be used for asynchronous tests.You can use whatever assertion framework you like. Chai.js is quite a good one and very flexible.ExampleHere's a subset of the unit test for the utils.js Nightwatch module:tests/utilsTest.jsconst assert = require('assert');const common = require('../../common.js');const Utils = common.require('util/utils.js');module.exports = {  'test Utils' : {    testFormatElapsedTime : function() {            var resultMs = Utils.formatElapsedTime(999);      assert.equal(resultMs, '999ms');            var resultSec = Utils.formatElapsedTime(1999);      assert.equal(resultSec, '1.999s');            var resultMin = Utils.formatElapsedTime(122299, true);      assert.equal(resultMin, '2m 2s / 122299ms');    },        testMakeFnAsync : function() {      function asyncFn(cb) {        cb();      }            function syncFn() {}            var convertedFn = Utils.makeFnAsync(1, syncFn);      var called = false;      convertedFn(function() {        called = true;      });            assert.equal(Utils.makeFnAsync(1, asyncFn), asyncFn);      assert.ok(called);    }  }};Asynchronous Unit TestsThe argument to the test function is the optional done callback which signals the test is complete.If present, the callback must be called when the async operation finishes.ExampleHere's unit test which checks if Nightwatch throws an error if you don't invoke the done callback within a set time (10 ms).module.exports = {  const assert = require('assert');    module.exports = {    'demo UnitTest' : function (done) {      assert.equal('TEST', 'TEST');            setTimeout(function() {          done();      }, 10);    }  };};Using a Combined ConfigurationBelow is an example of how you can combine end-to-end tests and unit tests in the same nightwatch.json configuration file.Notice the usage of exclude and filter properties.An empty exclude means we want to reset its value and rely only on filter.nightwatch.json{  \"src_folders\" : [\"./examples/tests\", \"./examples/unittests\"],  \"output_folder\" : \"./examples/reports\",      \"webdriver\" : {    \"start_process\": true,    \"server_path\": \"node_modules/.bin/chromedriver\",    \"port\": 9515  },    \"test_settings\" : {    \"default\" : {      \"launch_url\" : \"http://localhost\",      \"desiredCapabilities\": {        \"browserName\": \"chrome\"      },      \"exclude\" : \"./examples/unittests/*\"    },        \"unittests\" : {      \"unit_tests_mode\" : true,      \"filter\" : \"./examples/unittests/*\",      \"exclude\" : \"\"    }  }}Code CoverageAt the moment, Nightwatch doesn't provide a coverage reporter but it is something that's being planned for a future release.In the meantime you can write a custom reporter which will output coverage data. See the custom reporter section for details and the Mocha HTMLCov reporter for how the reporter should look like.3rd party coverage serviceThere are some hosted services which provide the reporting and metrics for you in a modern web interface. These services will typically require coverage data in LCOV format. Nightwatch uses coveralls.io.For details on how an LCOV reporter should look like and how to integrate with your project, you can check out the mocha-lcov-reporter.\u2190BackAPI testing", "url": "https://nightwatchjs.org/guide/writing-tests/write-nodejs-unit-integration-tests.html"}, {"title": "Test Doubles", "body": "Test Doubles in Nightwatch Test doubles, also known as mocks, stubs, or fakes, are used in testing to replace real dependencies with simulated ones to isolate the code being tested. Nightwatch provides support for test doubles through its mock command, which allows you to create stubs and mocks for dependencies.Installation1) Install the plugin from NPM:npm i @nightwatch/testdoubles --save-dev2) Add configuration:Edit your nightwatch.json (or nightwatch.conf.js) file and add the followingnightwatch.conf.jsmodule.exports = {  plugins: ['@nightwatch/testdoubles']  // other Nightwatch settings...}3) Disable the browser sessionWe also need to turn off the browser session, since we're only doing unit testing. This can be accomplished by setting these properties:nightwatch.conf.jsmodule.exports = {  // ....  testdoubles: {    start_session: false,    webdriver: {      start_process: false,    }  }}Requires Nightwatch 2.6.4 or higher.UsageOnce @nightwatch/testdoubles is installed and added to your configuration file, you can use the sinon object in your test cases to create test doubles. Here are some examples:SpyA spy is a function that records some metadata about its calls, such as the number of times it was called, the arguments it was called with, etc. Spies are useful for verifying that a function was called, or for inspecting the arguments it was called with.spy.jsdescribe('use spies in nightwatch', function() {  it('should log message when called', function({sinon}) {    const obj = {      hello: () => console.log('Hello!')    }    const sayHello = () => obj.hello();     const spy = sinon.spy(obj, 'hello'); // create a spy on hello    sayHello();    assert(spy.calledOnce);  // assert that the spy was called once    spy.restore();  // restore original hello function  })})This example creates a spy on the hello method of an object, and then calls the sayHello function. The assertion checks whether the spy was called once. Finally, the spy is restored to its original state.StubsA stub is a function that replaces the original function with a \"dummy\" implementation. This is useful when you need to control the behavior of a function during a test, for example to simulate an error condition.stub.jsdescribe('use stubs in nightwatch', function() {  it('stub hello', function({sinon}) {    const obj = {      hello: () => console.log('Hello!')    }    const sayHello = () => obj.hello();    const stub = sinon.stub(obj, 'hello').returns('hi'); // replace hello with a dummy implementation that returns 'hi'    const result = sayHello();    assert.strictEqual(result, 'hi'); // check that the stubbed function returned 'hi'  });});This example creates a stub on the console.log method and then calls it with the argument 'Hello!'. The assertion checks whether the stub was called once with the expected argument. Finally, the stub is restored to its original state.MocksA mock is a function that \"mocks\" an object, i.e. it creates a fake version of the object with the same interface as the real object. You can set expectations on the mock object, i.e. specify which methods should be called and with what arguments, and the mock will verify that these expectations are met during the test.creating a mock automatically attaches a Nightwatch assertion to it. mock.verify() runs the checks and reports errors if the checks fail.mock.jsdescribe('use mocks in nightwatch', function() {  it('mock hello obj', function({sinon}) {    const obj = {      hello: () => console.log('Hello!')    }    const sayHello = () => obj.hello();    const mock = sinon.mock(obj).expects('hello').atLeast(1).returns(null); //set a mock on hello    sayHello();    mock.verify(); // mocks comes with inbuilt assertion   })})This example creates a mock on the hello method of an object, and then calls the sayHello function. The mock.verify() method checks whether the mock was called at least once. Finally, the mock is restored to its original state.For more information on how to use spy, stub, and mock, see the Sinon.js documentation. Running API testsEnsure that the API tests are run against an environment where the start_session and webdriver -> start_process are set to false.npx nightwatch <path to tests> --env testdoublesWe hope these examples help you get started with using @nightwatch/testdoubles in your Nightwatch tests!", "url": "https://nightwatchjs.org/guide/writing-tests/test-doubles.html"}, {"title": "Nightwatch Inspector", "body": "Nightwatch InspectorOverviewThe Nightwatch inspector is designed to simplify authoring tests. Major advantages of using this are:Save time identifying selectorsBuild more robust tests Reduced back and forth between test file & browser as you can test commands in the browser itselfStart Nightwatch InspectorFollow these to start the Nightwatch Inspector:Step 1 - Add debug lineAdd browser.debug() in the test at a line where you want to start the Nightwatch inspector.Step 2 - Run test with debug flagRun the specific Nightwatch test with --debug test:npx nightwatch /test/inspector_demo.js --env chrome --debugStep 3 - Open Nightwatch selectorRunning the test would have opened up a browser and it would be paused at the line where .debug() was present. Now open dev-tools, click on >> and select Nightwatch Inspector.Explore modeTo get selector recommendations, you have to enable the explore mode. Once the explore mode is enabled and you point and click in the browser window, you will get selector recommendations as shown below:Click on any element to get the suggestion in the selector history.Try commandsTry out Nightwatch commands from the Nightwatch Inspector itself using the selectors from the selector history.You can copy the selector using copy button in the `Selector History` & paste it while using the commands.All successful commands will show up in Command History as shown belowYou can directly copy paste these in your test files and complete your test authoring very easily. Enjoy authoring tests with the Nightwatch inspector!\u2190BackVisual TestingNext PageUnit & integration testing\u2192", "url": "https://nightwatchjs.org/guide/writing-tests/nightwatch-inspector.html"}]